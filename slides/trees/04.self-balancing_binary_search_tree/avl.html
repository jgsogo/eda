<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>rboles AVL</h2>
        <h4>(Adelson-Velskii y Landis)</h4>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Propiedades</h2>
        <h4>(rboles AVL)</h4>
    </section>

    <section>
        <p>
            Los <span class="red">谩rboles AVL</span> son 谩rboles BB donde todo nodo cumple la propiedad de <span
                class="red">equilibrado AVL</span>.
        </p>
    </section>

    <section>
        <h4>Equilibrado AVL</h4>
        <p>
            La altura del sub谩rbol izquierdo y del sub谩rbol derecho no se diferencian en m谩s de una unidad.
        </p>
    </section>


    <section>
        <h4>Factor de equilibrio</h4>
        <p>
            Definimos <span class="red">factor de equilibrio</span> a la diferencia entre la altura del sub谩rbol derecho
            y el sur谩rbol izquierdo:
        </p>
        <p><code>Fe(nodo) = h(derecho) - h(izquierdo)</code></p>
    </section>

    <section>
        <p>En un 谩rbol AVL el factor de equilibrio de todo nodo ser谩 -1, 0 o +1</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-example.dot.png" />
        <p><small>Ejemplo 谩rbol AVL (el factor de equilibrado se indica en cada nodo)</small></p>
    </section>

    <section>
        <p>Tras la inserci贸n o borrado de un elemento los <span>ascendientes</span> del nodo pueden sufrir cambios en su
            factor de equilibrio.</p>
        <p class="fragment">Estos cambios, como mucho, ser谩n de una unidad.</p>
        <p class="fragment">El reequilibrado se realiza mediante <span class="red">rotaciones</span>.</p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Operaciones</h2>
        <h4>(rboles AVL)</h4>
    </section>

    <section>
        <h4>Operaciones de acceso</h4>
        <p>Las <span class="blue">operaciones de acceso</span> (altura, tama帽o, b煤squeda, recorrido) son id茅nticas a las
            de un 谩rbol BB.</p>
    </section>

    <section>
        <h4>Inserci贸n y borrado</h4>
        <p>Estas operaciones se realizan igual que en un 谩rbol BB, pero se a帽ade una etapa posterior de <span
                class="red">reequilibrado</span>.</p>
    </section>

    <section>
        <h4>Reequilibrado</h4>
        <p>
            El <span class="red">reequilibrado</span> recorre los ascendientes del nodo que ha sufrido modificaci贸n,
            recalcula sus factores de equilibrio y aplica las <span class="red">rotaciones</span> adecuadas cuando
            sea necesario.
        </p>
        <p>
            El recorrido se detiene en el <span class="blue">nodo ra铆z</span> o bien cuando el nodo actual no
            haya sufrido <span class="red">cambios en altura</span>.
        </p>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Cambios en altura</h2>
        <h4>(rboles AVL)</h4>
    </section>

    <section>
        <h4>Al insertar un nodo</h4>
        <p>
            Un nodo con <span class="blue">factor de equilibrio -1 贸 0</span> incrementar谩 su altura
            si su <span class="blue">hijo izquierdo</span> incrementa su altura.
        </p>
        <hr />
        <p>
            Si el <span class="blue">factor de equilibrio es 0 贸 +1</span> incrementar谩 su altura cuando lo haga su
            <span class="blue">hijo derecho</span>.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Cambios en altura al insertar un nodo</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-height-inc.png" />
    </section>

    <section>
        <h4>Al eliminar un nodo</h4>
        <p>
            Un nodo con <span class="blue">factor de equilibrio -1</span> decrementar谩 su altura
            si su <span class="blue">hijo izquierdo</span> decrementa su altura.
        </p>
        <hr />
        <p>
            Si el <span class="blue">factor de equilibrio es +1</span> decrementar谩 su altura cuando lo haga su <span
                class="blue">hijo derecho</span>.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Cambios en altura al eliminar un nodo</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-height-dec.png" />
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Rotaciones</h2>
        <h4>(rboles AVL)</h4>
    </section>

    <section>
        <p>
            Una <span class="red">rotaci贸n</span> es una reestructuraci贸n local de un sub谩rbol BB que mantiene la
            propiedad de ordenaci贸n.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Rotaci贸n izquierda</p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example1-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example1-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotaci贸n. A, B, C representan sub谩rboles equilibrados de altura h.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Rotaci贸n izquierda</p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-izq.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-mid.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotaci贸n. A, B, C, D representan sub谩rboles equilibrados de altura h.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-mid.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-example2-der.dot.png" />
                </td>
            </tr>
        </table>
        <p><small>Ejemplo de rotaci贸n. A, B, C, D representan sub谩rboles equilibrados de altura h.</small></p>
    </section>

    <section>
        <h4>Objetivo</h4>
        <p>
            El objetivo de las rotaciones siempre es reequilibrar un sub谩rbol que se ha desequilibrado al a帽adir
            o al eliminar un nodo.
        </p>
    </section>

    <section>
        <h4>Rotaci贸n izquierda</h4>
        <h6>-2|-1 &nbsp;&nbsp;&nbsp; -2|0</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Aplicamos una <span class="blue">rotaci贸n izquierda</span> cuando encontramos una de estas situaciones
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small>A increment贸 su altura o C disminuy贸 su altura</small>
                </td>
                <td>
                    <small>C disminuy贸 su altura</small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 1) Tras la <span class="blue">rotaci贸n izquierda</span> hay un cambio de altura en este sub谩rbol
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(A) + 2</code><br/>
                        <code>h(A) = h(B) + 1</code><br/>
                        <code>h(C) = h(B)</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(h(A), 1 + max(h(B), h(C)))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(B))</code><br/>
                        <code>h(y) = 1 + h(A)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 2) Tras la <span class="blue">rotaci贸n izquierda</span> el sub谩rbol mantiene su altura
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda2-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(A) + 2</code><br/>
                        <code>h(B) = h(A)</code><br/>
                        <code>h(C) = h(A) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(h(A), 1 + max(h(B), h(C)))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(B))</code><br/>
                        <code>h(y) = 1 + max(h(A), 1 + h(A))</code><br/>
                        <code>h(y) = 2 + h(A)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>


    <section>
        <h4>Rotaci贸n derecha</h4>
        <h6>2|1 &nbsp;&nbsp;&nbsp; 2|0</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Aplicamos una <span class="blue">rotaci贸n derecha</span> cuando encontramos una de estas situaciones
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small>A decrement贸 su altura o C increment贸 su altura</small>
                </td>
                <td>
                    <small>A disminuy贸 su altura</small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 1) Tras la <span class="blue">rotaci贸n derecha</span> hay un cambio de altura en este sub谩rbol
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(C) + 2</code><br/>
                        <code>h(B) = h(C) - 1</code><br/>
                        <code>h(A) = h(C) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(1 + max(h(A), h(B)), h(C))</code><br/>
                        <code>h(y) = 1 + max(1 + h(A), h(C))</code><br/>
                        <code>h(y) = 1 + h(C)</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Caso 2) Tras la <span class="blue">rotaci贸n derecha</span> el sub谩rbol mantiene su altura
        </p>
        <table>
            <tr>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2.dot.png" />
                </td>
                <td>
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha2-fix.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = h(C) + 2</code><br/>
                        <code>h(B) = h(C)</code><br/>
                        <code>h(A) = h(C) - 1</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(y) = 1 + max(1 + max(h(A), h(B)), h(C))</code><br/>
                        <code>h(y) = 1 + max(1 + h(B), h(C))</code><br/>
                        <code>h(y) = 2 + h(C)<code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Rotaci贸n derecha-izquierda</h4>
        <h6>-2|1</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Aplicamos una <span class="blue">rotaci贸n derecha-izquierda</span> cuando encontramos esta situaci贸n</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda.dot.png" />
        <p><small>Causas: borrado en D o inserci贸n en B 贸 C incrementando la altura de <code>z</code>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 1) <span class="blue">rotaci贸n derecha</span> en los nodos <code>y</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix1.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(B), h(C))</code><br/>
                        <code>h(A) = max(h(B), h(C))</code><br/>
                        <code>h(D) = max(h(B), h(C))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(A), h(B))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 2) <span class="blue">rotaci贸n izquierda</span> en los nodos <code>x</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix1.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha-izda-fix2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(A), h(B))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(z) = 2 + max(h(A), h(B), h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section>
        <h4>Rotaci贸n izquierda-derecha</h4>
        <h6>2|-1</h6>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Aplicamos una <span class="blue">rotaci贸n izquierda-derecha</span> cuando encontramos esta situaci贸n</p>
        <img class="r-stretch" src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha.dot.png" />
        <p><small>Causas: borrado en A o inserci贸n en B 贸 C incrementando la altura de <code>z</code>.</small></p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 1) <span class="blue">rotaci贸n izquierda</span> en los nodos <code>y</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix1.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(B), h(C))</code><br/>
                        <code>h(A) = max(h(B), h(C))</code><br/>
                        <code>h(D) = max(h(B), h(C))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>
            Paso 2) <span class="blue">rotaci贸n derecha</span> en los nodos <code>x</code> y <code>z</code>
        </p>
        <table>
            <tr>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix1.dot.png" />
                </td>
                <td style="padding:0px;">
                    <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda-dcha-fix2.dot.png" />
                </td>
            </tr>
            <tr>
                <td>
                    <small><small>
                        <code>h(x) = 3 + max(h(C), h(D))</code><br/>
                    </small></small>
                </td>
                <td>
                    <small><small>
                        <code>h(z) = 2 + max(h(A), h(B), h(C), h(D))</code><br/>
                    </small></small>
                </td>
            </tr>
        </table>
    </section>
</section>

<section data-transition="convex">
    <section data-state="darken"
        data-background="slides/trees/04.self-balancing_binary_search_tree/background-avl.jpeg">
        <h2>Implementaci贸n C++</h2>
        <h4>(rboles AVL)</h4>
    </section>

    <section>
        <p>
            En lo fundamental la implementaci贸n es igual que en un <code>BinarySearchTree</code>, a帽adiendo
            lo necesario para la operaci贸n de reequilibrado (factor de equilibrio, rotaciones,...).
        </p>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree.h`

```cpp
class AVLTree {
    public:
        AVLTree();

        // ... same as BinarySearchTree
        
    private:
        void rebalance(); // Function to call after every insertion/removal
};
```
<small>`AVLTree.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree::push`

Despu茅s de insertar el elemento, rebalanceamos

```cpp
void AVLTree::push(const TipoDato& dato) {
    _push(root, dato);
    rebalance();
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `AVLTree::remove`

Despu茅s de eliminar el elemento, rebalanceamos

```cpp
void AVLTree::remove(const TipoDato& dato) {
    // ... same as BinarySearchTree::remove

    // After everything is done, rebalance
    rebalance();
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section>
        <h4><code>AVLTree::rebalance</code></h4>
        <p>
            锔 La implementaci贸n que se muestra a continuaci贸n para el <span class="blue">rebalanceo</span> 
            no es la mejor ni la m谩s eficiente, se ha primado la simplicidad.
        </p>
    </section>

    <section>
        <p>Estrategia:</p>
        <ul>
            <li>Primero hijos, luego padres: <code>dfs_postorder</code>.</li>
            <li>Actuamos cuando el fator de equilibrio es -2 贸 2.</li>
        </ul>
    </section>

    <section data-markdown>
        <script type="text/template">
`AVLTree::rebalance`

Despu茅s de eliminar el elemento, rebalanceamos

```cpp[26-30|1-8|10-23]
void _rebalance(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    // DFS post-order strategy:
    if (element->left) {
        _rebalance(element->left);
    }
    else if (element->right) {
        _rebalance(element->right);
    }

    if (factor_equilibrio(element) == -2) {
        if (factor_equilibrio(element->left) == 1) {
            // First, rotate the child right
            rotate_right(element->left);
        }
        rotate_left(element);
    }
    else if (factor_equilibrio(element) == 2) {
        if (factor_equilibrio(element->right) == -1) {
            // First, rotate the child left
            rotate_left(element->right);
        }
        rotate_right(element);
    }
}

void AVLTree::rebalance() {
    if (root != nullptr) {
        _rebalance(root);
    }
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Funci贸n auxiliar `factor_equilibrio`:

```cpp
int factor_equilibrio(std::shared_ptr<ElementoArbolBinario> element) {
    return _height(element->right) - _height(element->left);
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Funci贸n auxiliar `rotate_left`:

```cpp
void rotate_left(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    auto old_parent = element;
    element = element->left;
    old_parent->left = element->right;
    element->right = old_parent;
}
```
<small>`AVLTree.cpp`</small>
<table>
    <tr>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1.dot.png" />
        </td>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-izda1-fix.dot.png" />
        </td>
    </tr>
</table>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Funci贸n auxiliar `rotate_right`:

```cpp
void rotate_right(std::shared_ptr<ElementoArbolBinario>& element) { // Note the reference
    auto old_parent = element;
    element = element->right;
    old_parent->right = element->left;
    element->left = old_parent;
}
```
<small>`AVLTree.cpp`</small>
<table>
    <tr>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1.dot.png" />
        </td>
        <td>
            <img src="slides/trees/04.self-balancing_binary_search_tree/avl-rotate-dcha1-fix.dot.png" />
        </td>
    </tr>
</table>
        </script>
    </section>

    <section>
        <h4><code>AVLTree::rebalance</code> (optimizaci贸n)</h4>
        <p>
            Todos los rebalanceos (si existen) ocurren en los <span class="blue">ascendientes</span> del nodo que se acaba de
            insertar o de borrar.
        </p>
        <hr/>
        <p class="fragment">
            En vez de realizar un recorrido DFS post-order podr铆amos almacenar en cada nodo el puntero al padre y utilizarlo
            para recorrer los ascendientes.
        </p>
    </section>
</section>


<section data-transition="convex">
    <section data-background="images/background-actividades.png">
        <h2>Ejercicios propuestos</h2>
    </section>

    <section>
        <h4> Tu propia biblioteca de TADs: avl_tree</h4>
        <p>Reune el c贸digo relacionado con los 谩rboles BB en tu ordenador, junto al de otros TAD</p>
    </section>

    <section>
        <p>Necesitar谩s a帽adir:</p>
        <ul>
            <li><code>AVLTree.h</code></li>
            <li><code>AVLTree.cpp</code></li>
        </ul>
    </section>

    <section>
        <p>Haz ejemplos con esta clase, aseg煤rate de que sus m茅todos funcionan para todos los escenarios posibles.</p>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa una funci贸n para realizar el recorrido DFS postorder en el `AVLTree` que acepte nodos del 谩rbol en su funci贸n _lambda_

```cpp
class AVLTree {
    public:
        AVLTree();

        // ...
        
    private:
        void dfs_postorder(std::function<void (std::shared_ptr<ElementoArbolBinario>&)> action) const;
};
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa el m茅todo `AVLTree::rebalance` utilizando la funci贸n `AVLTree::dfs_postorder` anterior:

```cpp
void AVLTree::rebalance() {
    // This is the action we will execute on every node
    std::function<void (std::shared_ptr<ElementoArbolBinario>&)> action = [](std::shared_ptr<ElementoArbolBinario>& elem) {
        if (factor_equilibrio(elem) == -2) {
            // TODO
        }
        else if (factor_equilibrio(elem) == 2) {
            // TODO
        }
    };

    // Traverse the tree using DFS post-order strategy
    dfs_postorder(action);
}
```
<small>`AVLTree.cpp`</small>
        </script>
    </section>
</section>