<section data-transition="convex">
    <section>
        <h2>Definiciones y propiedades</h2>
    </section>

    <section>
        <h4>√Årbol</h4>
        <p>
            Un <span class="blue">√°rbol</span> es un TAD que consta de un nodo (<span class="red">nodo ra√≠z</span>) y
            una lista o conjunto de sub√°rboles.
        </p>
    </section>

    <section>
        <h4>√Årbol ordenado (√°rbol)</h4>
        <p>
            Cuando el orden de los sub√°rboles es importante (lista), se dice que es un <span class="blue">√°rbol
                ordenado</span> (*).
        </p>
        <p class="footnote">(*) Por defecto un √°rbol se considera ordenado.</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>Ejemplo de √°rbol [ordenado]</p>
        <img class="stretch" src="slides/trees/00.trees/tree.dot.png" />
        <p><small>Se dice que es ordenado porque los sub√°rboles con nodo ra√≠z <code>b</code>, <code>c</code> y
                <code>d</code> son una lista.</small></p>
    </section>

    <section>
        <h4>Tipos de nodos</h4>
        <ul>
            <li><strong class="blue">Nodo ra√≠z</strong>: <em>cabeza</em> o primer elemento del √°rbol.</li>
            <li><strong class="blue">Nodo hijo</strong>: son los nodos ra√≠z de los sub√°rboles.</li>
            <li><strong class="blue">Nodo padre</strong>: si <code>b</code> es un nodo hijo de <code>a</code>, entonces
                <code>a</code> es el nodo padre de <code>b</code>.</li>
            <li><strong class="blue">Nodo hoja o externo</strong>: nodo que no tiene hijos.</li>
            <li><strong class="blue">Nodo interno</strong>: cualquier nodo con alg√∫n hijo.</li>
        </ul>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <div class="left">
            <img src="slides/trees/00.trees/tree-node-types.dot.png" />
        </div>
        <div class="right">
            <p>Tipos de nodos</p>
            <ul>
                <li class="red">Nodo ra√≠z</li>
                <li class="blue">Nodo hoja o externo</li>
                <li>Nodo interno</li>
            </ul>
        </div>
    </section>

    <section>
        <h4>Camino</h4>
        <p>
            Cualquier secuencia de nodos <code>n<sub>1</sub>...n<sub>p</sub></code> que cumpla que cada nodo es el padre
            del siguiente en la secuencia.
        </p>
        <p class="fragment">La <span class="blue">longitud de un camino</span> es el n√∫mero de nodos menos uno
            (<code>p-1</code>)</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Descendientes</h4>
        <div class="left">
            <p>Todos los nodos accesibles por un camino que comience en dicho nodo.</p>
            <hr />
            <p>Los descendientes del nodo <code class="blue">c</code> son <code class="red">{e, f, g}</code></p>
        </div>
        <div class="right">
            <img src="slides/trees/00.trees/tree-descendents.dot.png" />
        </div>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h4>Ascendientes</h4>
        <div class="left">
            <p>Nodos del camino que va desde el nodo ra√≠z hasta el nodo en consideraci√≥n.</p>
            <hr />
            <p>Los asciendentes del nodo <code class="blue">g</code> son <code class="red">{a, c, f}</code></p>
        </div>
        <div class="right">
            <img src="slides/trees/00.trees/tree-ascendents.dot.png" />
        </div>
    </section>

    <section>
        <h4>Altura</h4>
        <p>
            La <span class="blue">altura de un nodo</span> es la logitud del camino m√°s largo que
            comienza en el nodo y termina en una hoja.</p>
        <p class="fragment">
            La <span class="blue">altura de un √°rbol</span> es la altura de su nodo ra√≠z.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/00.trees/tree-altura.dot.png" />
        <p>La altura de un nodo se puede calcular como la mayor de las alturas de sus nodos hijo m√°s una unidad.</p>
    </section>

    <section>
        <h4>Profundidad (nivel)</h4>
        <p>
            La <span class="blue">profundidad (nivel) de un nodo</span> es la logitud del camino (√∫nico) que comienza en la ra√≠z
            y termina en el nodo.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/00.trees/tree-depth.dot.png" />
        <p>La profundidad (nivel) de un nodo es la profundidad de su nodo padre m√°s uno.</p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido de √°rboles</h2>
    </section>

    <section>
        <h4>B√∫squeda no informada</h4>
        <p>
            Se recorre todo el √°rbol sin tener una pista de donde se encuentra el elemento buscado. Tambi√©n se conoce
            como <span class="blue">b√∫squeda a ciegas</span>.
        </p>
    </section>

    <section>
        <p>Estrategias de b√∫squeda no informada:</p>
        <ul>
            <li>Recorrido en profundidad</li>
            <li>Recorrido en anchura</li>
        </ul>
    </section>

    <section>
        <h4>B√∫squeda informada</h4>
        <p>
            Cuando existe un criterio de ordenaci√≥n para los elementos del √°rbol (*) se puede optimizar el
            recorrido del √°rbol.
        </p>
        <hr />
        <p>
            Los <a href="13.binary_search_trees.html">√°rboles binarios de b√∫squeda</a> son ejemplos de √°rboles que
            presentan esta propiedad.
        </p>
        <div class="footnote">(*) No confundir con √°rbol ordenado, que se refiere al orden de los sub√°rboles.</div>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido en profundidad</h2>
        <h4>Depth-first search (DFS)</h4>
    </section>

    <section>
        <p>En un <span class="blue">recorrido en profundidad</span> se recorre cada uno de los sub√°rboles de un nodo
            antes de pasar al siguiente sub√°rbol del mismo nodo (*).</p>
        <div class="footnote">(*) N√≥tese que es una definici√≥n recursiva.</div>
    </section>

    <section>
        <h4>Recorrido pre-orden</h4>
        <p>Se vista el nodo ra√≠z y luego se recorre en pre-orden cada uno de los sub√°rboles (recursivo).</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS pre-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png" />
        <p><code>a, b, c, e, f, g, d</code></p>
    </section>

    <section>
        <h4>Recorrido post-orden</h4>
        <p>Se recorre en post-orden cada uno de los sub√°rboles y luego se visita el nodo ra√≠z (recursivo).</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS post-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png" />
        <p><code>b, e, g, f, c, d, a</code></p>
    </section>

    <section>
        <h4>Recorrido in-orden (*)</h4>
        <p>
            Se recorre en in-orden el primer sub√°rbol (si existe), luego se visita el nodo ra√≠z y despu√©s se recorre en
            in-orden los sub√°rboles restantes (recursivo).
        </p>
        <div class="footnote">Tiene sentido fundamentalmente en <a href="11.binary_trees.html">√°rboes binarios</a>.</div>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>DFS in-orden</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-dfs-preorden.dot.png"/>
        <p><code>b, a, e, c, g, f, d</code></p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Recorrido en anchura/amplitud</h2>
        <h4>Breadth-first search (BFS)</h4>
    </section>

    <section>
        <p>
            En un <span class="blue">recorrido en anchura</span> se recorren todos los nodos de un mismo nivel antes de
            pasar al siguiente nivel.
        </p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <p>BFS</p>
        <img class="r-stretch" src="slides/trees/00.trees/tree-bfs.dot.png"/>
        <p><code>a, b, c, d, e, f, g</code></p>
    </section>
</section>

<section data-transition="convex">
    <section>
        <h2>Implementaci√≥n</h2>
        <h4>√Årboles con C++</h4>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <img class="r-stretch" src="slides/trees/00.trees/tree-structs.dot.png"/>
        <p><small>Un √°rbol es una colecci√≥n de elementos enlazados donde estos elementos almacenan datos. El √°rbol ser√° el puntero al nodo ra√≠z.</small></p>
    </section>

    <section data-markdown>
        <script type="text/template">
### `ElementoArbol.h`

Cada elemento contiene datos y punteros a los hijos

```cpp
class ElementoArbol {
    public:
        // Members
        TipoDato dato;
        std::vector<std::shared_ptr<ElementoArbol>> children;
    public:
        // Constructor 
        ElementoArbol(const TipoDato& dato_) : dato{dato_} {};
}
```
<small>`ElementoArbol.h`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `Tree.h`

El √°rbol es el puntero al nodo ra√≠z y las operaciones que pueden realizarse con √©l (*).

```cpp[3,6-7|9-12|13-14]
class Tree {
    protected:
        std::shared_ptr<ElementoArbol> root = nullptr;

    public:
        Tree();  // Creates empty tree
        Tree(const TipoDato& dato);  // Creates tree with root node

        // Member functions (properties of the tree structure)
        int height() const;
        int size() const; // Returns number of nodes

        // A way to add subtrees to an existing tree
        void add_subtree(const Tree& subtree);
}
```
<!-- .element: class="r-stretch" -->
<small>`Tree.h`</small>

As√≠ como para las listas, colas y pilas existen en la biblioteca est√°ndard de C++, los √°rboles (en general) no, as√≠ que no podemos referirnos a una interfaz est√°ndard. <!-- .element: class="footnote" -->
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Creando un √°rbol: con la interfaz de que disponemos tenemos que ir nivel a nivel ü§∑‚Äç‚ôÇÔ∏è

```cpp[5-6|8-11|13-17|19-21|23-25]
#include <iostream>
#include "Tree.h"

int main() {
    // Nivel 3
    Tree g{TipoDato{"g"}};
    
    // Nivel 2
    Tree e{TipoDato{"e"}};
    Tree f{TipoDato{"f"}};
    f.add_subtree(g);

    // Nivel 1
    Tree b{TipoDato{"b"}};
    Tree c{TipoDato{"c"}};
    Tree d{TipoDato{"d"}};
    c.add_subtree(f);

    // Nivel 0
    Tree a{TipoDato{"a"}};
    a.add_subtree(c);

    // Get some properties
    std::cout << "Altura: " << a.height() << std::endl;
    std::cout << "Tama√±o/peso: " << a.size() << std::endl;
}
```
<small>`main.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### `Tree.cpp`

Sabemos c√≥mo implementar algunas funciones

```cpp

// Constructor for an empty tree
Tree::Tree() {}

// Constructor for a tree with the root node
Tree::Tree(const TipoDato& dato) {
    root = std::make_shared<ElementoArbol>(ElementoArbol{dato});
}

void Tree::add_subtree(const Tree& subtree) {
    if (subtree.root != nullptr) {
        root->children.push_back(subtree.root);
    }
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
... algunas son recursivas üò® 

```cpp
#include <algorithm>

int _height(std::shared_ptr<ElementoArbol> element) {
    if (element->children.empty()) {
        return 0;
    }
    else {
        int max_children = 0;
        for (auto child: element->children) {
            max_children = std::max(max_children, _height(child));
        }
        return 1 + max_children;
    }
}

int Tree::height() const {
    return _height(root);
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
... algunas son recursivas üò® 

```cpp
int _size(std::shared_ptr<ElementoArbol> element) {
    int n_nodes = 1;
    for (auto child: element->children) {
        n_nodes += _size(child);
    }
    return n_nodes;
}

int Tree::size() const {
    return _size(root);
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Implementaci√≥n DFS</h2>
        <h4>Recorrido en profundidad con C++</h4>
    </section>

    <section data-markdown>
        <script type="text/template">
### [DFS] pre-order

```cpp
void dfs_preorder(std::shared_ptr<ElementoArbol> elem,
                  std::function<void (TipoDato&)> action) {
    action(elem->dato);
    for (auto child: elem->children) {
        dfs_preorder(child, action);
    }
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### [DFS] post-order

```cpp
void dfs_postorder(std::shared_ptr<ElementoArbol> elem,
                  std::function<void (TipoDato&)> action) {
    for (auto child: elem->children) {
        dfs_postorder(child, action);
    }
    action(elem->dato);
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
### [DFS] in-order

```cpp
void dfs_inorder(std::shared_ptr<ElementoArbol> elem,
                  std::function<void (TipoDato&)> action) {
    if (!elem->children.empty()) {
        dfs_inorder(elem->children[0], action)
    }
    action(elem->dato);

    for (int i=1; i<elem->children.size(); i++) {
        dfs_inorder(elem->children[1], action);
    }
}
```
<small>`Tree.cpp`</small>
        </script>
    </section>
</section>


<section data-transition="convex">
    <section>
        <h2>Implementaci√≥n BFS</h2>
        <h4>Recorrido en anchura con C++</h4>
    </section>
</section>
