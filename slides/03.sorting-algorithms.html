<section data-transition="convex">

    <section data-background="images/marie-kondo.jpg">
        <div class="credit black">Imagen: Marie Kondo, Does it spark joy?</div>
        <h2 class="box-shadow-white black">Algoritmos de ordenación</h2>
        <p class="box-shadow-white black">Fin en sí mismo o como paso previo</p>
    </section>

    <section data-menu-title="Relación de orden">
        <p>Tiene que existir una relación de orden definida entre los elementos</p>
    </section>

    <section data-markdown>
        <script type="text/template">
```cpp

// Declare some kind of element with different attributes
enum class Color {red, blue, green };
struct Element {
    std::string name;
    Color color;
    int size;
}

// Define different ordering function
bool order_by_name(const Element& lhs, const Element& rhs) {
    return lhs.name < rhs.name;
}

bool order_by_color(const Element& lhs, const Element& rhs) {
    return lhs.color < rhs.color;
}
```
        </script>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h3>Orden estable</h3>
        <img class="stretch" src="slides/algoritmos/sort-order-stable.dot.png"></img>
        <p>Se conserva el <span class="red">orden relativo</span> entre elementos</p>
    </section>

    <section data-background-color="rgb(255, 255, 255)">
        <h3>Orden inestable</h3>
        <img class="stretch" src="slides/algoritmos/sort-order-inestable.dot.png"></img>
        <p><span class="red">NO garantizan</span> el orden relativo</p>
    </section>


    <section data-background-video-muted>
        <p>Time -vs- Space</p>
        <div class="credit">Link: <a href="https://www.youtube.com/watch?v=ZZuD6iUe3Pc">Youtube</a></div>
        <iframe class="r-stretch" src="https://www.youtube.com/embed/ZZuD6iUe3Pc" frameborder="0"
            allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
            allowfullscreen></iframe>
    </section>

</section>

<section data-external-slide-replace="slides/algoritmos/sort-bubble.html"></section>
<section data-external-slide-replace="slides/algoritmos/sort-selection.html"></section>
<section data-external-slide-replace="slides/algoritmos/sort-mergesort.html"></section>
<section data-external-slide-replace="slides/algoritmos/sort-quicksort.html"></section>

<section>
    <section>
        <h2>Ejercicios propuestos</h2>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa los algoritmos anteriores para que acepten vectores de `float` 

```cpp
void bubble_sort(std::vector<float>& elements);

void selection_sort(std::vector<float>& elements);

std::vector<float> merge_sort(const std::vector<float>& elements);

void quick_sort(std::vector<float>& elements, int left_index, int right_index);

```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Implementa los algoritmos anteriores para que ordenen vectores de `std::string` según
el número de letras de cada palabra (a igualdad de letras, utilizar el orden lexicográfico). 

```cpp
void bubble_sort(std::vector<std::string>& elements);

void selection_sort(std::vector<std::string>& elements);

std::vector<std::string> merge_sort(const std::vector<std::string>& elements);

void quick_sort(std::vector<std::string>& elements, int left_index, int right_index);

```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">
Generar un vector con un millón de números aleatorios y medir el tiempo que tarda cada 
uno de los algoritmos. ¿Se corresponde con lo esperado?

```cpp
void bubble_sort(std::vector<std::string>& elements);

void selection_sort(std::vector<std::string>& elements);

std::vector<std::string> merge_sort(const std::vector<std::string>& elements);

void quick_sort(std::vector<std::string>& elements, int left_index, int right_index);

```
        </script>
    </section>

    <section data-markdown>
        <script type="text/template">

Comparar los tiempos de `quick_sort` para diferentes vectores con un millón de elementos:

 * Números aleatorios.
 * Un vector ya ordenado.
 * Un vector ordenado en orden inverso.
 * Un vector con todos sus elementos iguales.

¿Cuál es el peor caso? ¿Hay mucha diferencia entre el mejor y el [peor caso](https://youtu.be/es2T6KY45cA?t=247)? 
        </script>
    </section>

    
</section>
